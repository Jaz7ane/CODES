<!DOCTYPE html> 
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Magenta Ray Heart</title>
<style>
    body {
        margin: 0;
        padding: 0;
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
        background: radial-gradient(circle at center, #000 40%, #050505);
        overflow: hidden;
    }
    canvas {
        background: transparent;
    }
</style>
</head>
<body>
<canvas id="c" width="900" height="900"></canvas>

<script>
const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d");

const centerX = canvas.width / 2;
const centerY = canvas.height / 2;

const numLines = 300;
let currentLine = 0;
let lineLength = 0;


const growSpeed = 35; 
let glowPulse = 0;

ctx.lineCap = "round";
ctx.globalCompositeOperation = "lighter";   

let order = [];
for (let i = 0; i < numLines / 2; i++) {
    order.push(i, numLines - i - 1);
}
order.sort(() => Math.random() - 0.5);

let completed = [];
let particles = [];
let sparkles = [];

function getHeartPoint(t) {
    const s = 17;
    const x = s * 16 * Math.pow(Math.sin(t), 3);
    const y = -s * (13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t));
    return { x, y };
}

function drawHeartParticle(x, y, size, alpha) {
    ctx.save();
    ctx.translate(x, y);
    ctx.scale(size, size);
    ctx.globalAlpha = alpha;

    ctx.beginPath();
    ctx.moveTo(0, -2);
    ctx.bezierCurveTo(2, -4, 6, -2, 0, 4);
    ctx.bezierCurveTo(-6, -2, -2, -4, 0, -2);

    ctx.fillStyle = "rgba(255,255,255,1)"; 
    ctx.fill();

    ctx.restore();
    ctx.globalAlpha = 1;
}


function addOrbitParticles() {
    for (let i = 0; i < 3; i++) {
        particles.push({
            angle: Math.random() * Math.PI * 2,
            dist: 240 + Math.random() * 50,
            speed: 0.004 + Math.random() * 0.004,
            size: 0.2 + Math.random() * 0.2,   
            alpha: 0.9 + Math.random() * 0.1  
        });
    }
}

function drawOrbitParticles() {
    for (let p of particles) {
        p.angle += p.speed;
        const x = centerX + Math.cos(p.angle) * p.dist;
        const y = centerY + Math.sin(p.angle) * p.dist;
        drawHeartParticle(x, y, p.size, p.alpha);
    }
}

function addSparkle(x, y) {
    sparkles.push({
        x, y,
        life: 1,
        size: 4 + Math.random() * 4
    });
}
function drawSparkles() {
    sparkles = sparkles.filter(s => s.life > 0);
    for (let s of sparkles) {
        ctx.globalAlpha = s.life;
        ctx.beginPath();
        ctx.arc(s.x, s.y, s.size, 0, Math.PI * 2);
        ctx.fillStyle = "white";
        ctx.fill();
        s.life -= 0.03;
    }
    ctx.globalAlpha = 1;
}

function animate() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    glowPulse += 0.06;
    const pulseScale = 1 + Math.sin(glowPulse) * 0.02;

    drawOrbitParticles();

    ctx.save();
    ctx.translate(centerX, centerY);
    ctx.scale(pulseScale, pulseScale);
    ctx.translate(-centerX, -centerY);

    for (let line of completed) {
        const grd = ctx.createLinearGradient(centerX, centerY, line.x, line.y);
        grd.addColorStop(0, "rgba(255,50,50,0.9)");
        grd.addColorStop(1, "rgba(255,0,255,0.9)");

        ctx.strokeStyle = grd;
        ctx.lineWidth = 2.5;

        ctx.beginPath();
        ctx.moveTo(centerX, centerY);
        ctx.lineTo(line.x, line.y);
        ctx.stroke();
    }

    if (currentLine < numLines) {
        const index = order[currentLine];
        const t = (index / numLines) * 2 * Math.PI;
        const point = getHeartPoint(t);

        const targetX = centerX + point.x * pulseScale;
        const targetY = centerY + point.y * pulseScale;

        const dx = targetX - centerX;
        const dy = targetY - centerY;
        const dist = Math.sqrt(dx*dx + dy*dy);

        const remaining = dist - lineLength;
       
        const grd = ctx.createLinearGradient(centerX, centerY, targetX, targetY);
        grd.addColorStop(0, "rgba(255,50,50,0.9)");
        grd.addColorStop(1, "rgba(255,0,255,0.9)");
        ctx.strokeStyle = grd;

        if (remaining <= growSpeed) {
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(centerX, centerY);
            ctx.lineTo(targetX, targetY);
            ctx.stroke();

            completed.push({ x: targetX, y: targetY });
            addSparkle(targetX, targetY);

            currentLine++;
            lineLength = 0;
        } else {
            const ratio = lineLength / dist;
            const endX = centerX + dx * ratio;
            const endY = centerY + dy * ratio;

            ctx.lineWidth = 2.5;
            ctx.beginPath();
            ctx.moveTo(centerX, centerY);
            ctx.lineTo(endX, endY);
            ctx.stroke();

            lineLength += growSpeed;
        }
    }

    ctx.restore();
    drawSparkles();

    if (Math.random() < 0.1) addOrbitParticles();
    requestAnimationFrame(animate);
}

animate();
</script>
</body>
</html>
