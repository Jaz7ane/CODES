<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Floating Lanterns</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            background: linear-gradient(to bottom, #0a0a2a 0%, #1a1430 30%, #2d1b19 100%);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }

        .container {
            position: relative;
            width: 100%;
            height: 100vh;
            overflow: hidden;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        .controls {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 100;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        button {
            background: rgba(255, 220, 150, 0.2);
            border: 1px solid rgba(255, 200, 100, 0.5);
            color: rgba(255, 220, 150, 0.9);
            padding: 8px 15px;
            border-radius: 20px;
            cursor: pointer;
            backdrop-filter: blur(5px);
            transition: all 0.3s ease;
        }

        button:hover {
            background: rgba(255, 220, 150, 0.3);
            transform: scale(1.05);
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="controls">
            <button id="addLanterns">Add Lanterns</button>
            <button id="reset">Reset</button>
        </div>
        <canvas id="canvas"></canvas>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const addLanternsButton = document.getElementById('addLanterns');
        const resetButton = document.getElementById('reset');

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        const stars = [];
        for (let i = 0; i < 300; i++) {
            stars.push({
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height * 0.8,
                size: Math.random() * 1.5 + 0.5,
                opacity: Math.random() * 0.7 + 0.3,
                twinkleSpeed: Math.random() * 0.02 + 0.01,
                twinkleOffset: Math.random() * Math.PI * 2
            });
        }

        const mountains = [];
        for (let i = 0; i < 5; i++) {
            mountains.push({
                x: (i / 5) * canvas.width,
                height: Math.random() * 100 + 50,
                width: canvas.width / 4,
                color: `rgba(20, 15, 30, ${0.5 + i * 0.1})`
            });
        }

        class Lantern {
            constructor(x = null, y = null, isUserCreated = false) {
                this.reset(x, y, isUserCreated);
            }

            reset(x = null, y = null, isUserCreated = false) {
                this.x = x !== null ? x : Math.random() * canvas.width;
                this.y = y !== null ? y : canvas.height + Math.random() * 100;
                this.z = Math.random() * 1000;
                this.size = (1000 - this.z) / 1000 * 30 + 15;
                this.speedY = -(Math.random() * 0.4 + 0.2) * (this.size / 20);
                this.speedX = (Math.random() - 0.5) * 0.2;
                this.opacity = Math.random() * 0.3 + 0.7;
                this.wobble = Math.random() * Math.PI * 2;
                this.wobbleSpeed = Math.random() * 0.02 + 0.01;
                this.glow = Math.random() * 0.5 + 0.5;
                this.glowSpeed = Math.random() * 0.02 + 0.01;
                this.rotation = (Math.random() - 0.5) * 0.2; 
                this.rotationSpeed = (Math.random() - 0.5) * 0.002; 
                this.turbulence = Math.random() * 0.5;
                this.turbulenceSpeed = Math.random() * 0.02 + 0.01;
                this.life = 1;
                this.fadeOut = false;
                this.flickerSpeed = Math.random() * 0.1 + 0.05;
                this.flickerOffset = Math.random() * Math.PI * 2;
                this.windInfluence = Math.random() * 0.5 + 0.5;
                this.riseSpeedVariation = Math.random() * 0.2 + 0.9;
                
                if (isUserCreated) {
                    this.y = canvas.height + 50;
                    this.speedY = -(Math.random() * 0.3 + 0.2);
                }
            }

            update(wind) {
                this.x += this.speedX + Math.sin(this.wobble) * 0.3 + 
                          Math.sin(this.turbulence) * 0.2 + 
                          wind * this.windInfluence;
               
                this.y += this.speedY * this.riseSpeedVariation;
                this.speedY *= 0.9998; 
               
                this.wobble += this.wobbleSpeed;
                this.turbulence += this.turbulenceSpeed;
                this.glow += this.glowSpeed;
                
                this.rotation += (Math.sin(this.wobble) * 0.005) + this.rotationSpeed;
                this.rotation = Math.max(-0.3, Math.min(0.3, this.rotation));
              
                if (Math.random() < 0.005) {
                    this.speedX += (Math.random() - 0.5) * 0.02;
                    this.speedX = Math.max(-0.5, Math.min(0.5, this.speedX));
                }
               
                if (this.y < canvas.height * 0.1 && !this.fadeOut) {
                    this.fadeOut = true;
                }
                
                if (this.fadeOut) {
                    this.life -= 0.0015;
                    if (this.life <= 0) {
                        this.reset();
                    }
                }

                if (this.y < -100 || this.x < -100 || this.x > canvas.width + 100) {
                    this.reset();
                }
            }
 
            draw() {
                const x = this.x;
                const y = this.y;
                const size = this.size;
               
                const flicker = Math.sin(Date.now() * this.flickerSpeed + this.flickerOffset) * 0.2 + 0.8;
                const glowIntensity = Math.sin(this.glow) * 0.3 + 0.7;
                const combinedIntensity = flicker * glowIntensity * this.life;

                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(this.rotation);

                const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, size * 3);
                gradient.addColorStop(0, `rgba(255, 210, 120, ${this.opacity * combinedIntensity * 0.7})`);
                gradient.addColorStop(0.2, `rgba(255, 185, 85, ${this.opacity * combinedIntensity * 0.45})`);
                gradient.addColorStop(0.5, `rgba(255, 160, 60, ${this.opacity * combinedIntensity * 0.25})`);
                gradient.addColorStop(1, 'rgba(255, 140, 40, 0)');

                ctx.fillStyle = gradient;
                ctx.fillRect(-size * 3, -size * 3, size * 6, size * 6);


                const width = size * 0.8;
                const height = size * 1.4;
               
                ctx.strokeStyle = `rgba(200, 150, 70, ${this.opacity * this.life * 0.8})`;
                ctx.lineWidth = 2;
               
                ctx.beginPath();
                ctx.moveTo(-width/2, -height/2);
                ctx.quadraticCurveTo(0, -height/2 - size*0.2, width/2, -height/2);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.moveTo(-width/2.5, height/2);
                ctx.quadraticCurveTo(0, height/2 + size*0.1, width/2.5, height/2);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.moveTo(-width/2, -height/2);
                ctx.lineTo(-width/2.5, height/2);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.moveTo(width/2, -height/2);
                ctx.lineTo(width/2.5, height/2);
                ctx.stroke();
                
                ctx.fillStyle = `rgba(255, 220, 150, ${this.opacity * this.life * 0.4})`;
                ctx.beginPath();
                ctx.moveTo(-width/2, -height/2);
                ctx.quadraticCurveTo(0, -height/2 - size*0.2, width/2, -height/2);
                ctx.quadraticCurveTo(width/2 + size*0.1, 0, width/2.5, height/2);
                ctx.quadraticCurveTo(0, height/2 + size*0.1, -width/2.5, height/2);
                ctx.quadraticCurveTo(-width/2 - size*0.1, 0, -width/2, -height/2);
                ctx.closePath();
                ctx.fill();
                
                const innerGlow = ctx.createRadialGradient(0, 0, 0, 0, 0, size * 0.8);
                innerGlow.addColorStop(0, `rgba(255, 235, 190, ${this.opacity * combinedIntensity * 0.9})`);
                innerGlow.addColorStop(0.5, `rgba(255, 205, 110, ${this.opacity * this.life * 0.6})`);
                innerGlow.addColorStop(1, 'rgba(255, 180, 80, 0)');

                ctx.fillStyle = innerGlow;
                ctx.beginPath();
                ctx.arc(0, 0, size * 0.8, 0, Math.PI * 2);
                ctx.fill();


                ctx.fillStyle = `rgba(255, 250, 220, ${this.opacity * combinedIntensity})`;
                ctx.beginPath();
                ctx.arc(0, -size * 0.1, size * 0.3, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore();
            }
        }

        class Particle {
            constructor(x = null, y = null) {
                this.reset(x, y);
            }

            reset(x = null, y = null) {
                this.x = x !== null ? x : Math.random() * canvas.width;
                this.y = y !== null ? y : canvas.height + Math.random() * 100;
                this.z = Math.random() * 1000;
                this.size = (1000 - this.z) / 1000 * 3 + 0.5;
                this.speedY = -(Math.random() * 0.8 + 0.4) * (this.size / 2);
                this.speedX = (Math.random() - 0.5) * 0.3;
                this.opacity = Math.random() * 0.6 + 0.4;
                this.twinkle = Math.random() * Math.PI * 2;
                this.twinkleSpeed = Math.random() * 0.05 + 0.02;
                this.life = 1;
            }

            update(wind) {
                this.y += this.speedY;
                this.x += this.speedX + wind * 0.5;
                this.twinkle += this.twinkleSpeed;
                
                if (Math.random() < 0.05) {
                    this.speedX += (Math.random() - 0.5) * 0.1;
                }

                this.life -= 0.002;
                if (this.life <= 0 || this.y < -10) {
                    this.reset();
                }
            }

            draw() {
                const twinkleOpacity = Math.sin(this.twinkle) * 0.5 + 0.5;
                ctx.fillStyle = `rgba(255, 230, 170, ${this.opacity * twinkleOpacity * this.life})`;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        const lanterns = [];
        const particles = [];

        for (let i = 0; i < 25; i++) {
            lanterns.push(new Lantern());
        }

        for (let i = 0; i < 100; i++) {
            particles.push(new Particle());
        }

        lanterns.forEach((lantern, i) => {
            lantern.y = canvas.height + (i / lanterns.length) * canvas.height - Math.random() * canvas.height;
        });

        let wind = 0;
        let windTarget = 0;
        let lastWindChange = 0;

        function updateWind() {
            const now = Date.now();
            if (now - lastWindChange > 5000) { 
                windTarget = (Math.random() - 0.5) * 0.5;
                lastWindChange = now;
            }
       
            wind += (windTarget - wind) * 0.01;
        }

        function drawStars() {
            stars.forEach(star => {
                const twinkle = Math.sin(star.twinkleSpeed * Date.now() / 100 + star.twinkleOffset) * 0.5 + 0.5;
                ctx.fillStyle = `rgba(255, 255, 255, ${star.opacity * twinkle})`;
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        function drawMountains() {
            mountains.forEach(mountain => {
                ctx.fillStyle = mountain.color;
                ctx.beginPath();
                ctx.moveTo(mountain.x, canvas.height);
                ctx.lineTo(mountain.x + mountain.width/2, canvas.height - mountain.height);
                ctx.lineTo(mountain.x + mountain.width, canvas.height);
                ctx.closePath();
                ctx.fill();
            });
        }

        canvas.addEventListener('click', (e) => {
            for (let i = 0; i < 3; i++) {
                setTimeout(() => {
                    lanterns.push(new Lantern(e.clientX, e.clientY, true));
                    for (let j = 0; j < 5; j++) {
                        particles.push(new Particle(
                            e.clientX + (Math.random() - 0.5) * 30, 
                            e.clientY + (Math.random() - 0.5) * 30
                        ));
                    }
                }, i * 200);
            }
        });

        addLanternsButton.addEventListener('click', () => {
            for (let i = 0; i < 10; i++) {
                setTimeout(() => {
                    lanterns.push(new Lantern(
                        Math.random() * canvas.width,
                        canvas.height + 50,
                        true
                    ));
                }, i * 100);
            }
        });

        resetButton.addEventListener('click', () => {
            lanterns.length = 0;
            particles.length = 0;
            
            for (let i = 0; i < 25; i++) {
                lanterns.push(new Lantern());
            }
            
            for (let i = 0; i < 100; i++) {
                particles.push(new Particle());
            }
        });

        function animate() {
            updateWind();
            
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#0a0a2a');
            gradient.addColorStop(0.5, '#1a1430');
            gradient.addColorStop(1, '#2d1b19');
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            drawMountains();
            
            drawStars();
          
            ctx.fillStyle = 'rgba(26, 20, 48, 0.03)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const all = [...lanterns, ...particles].sort((a, b) => b.z - a.z);

            all.forEach(item => {
                item.update(wind);
                item.draw();
            });

            requestAnimationFrame(animate);
        }

        animate();
    </script>
</body>
</html>