<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Animated Heart</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: black;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <canvas id="heartCanvas"></canvas>

    <script>
        const canvas = document.getElementById('heartCanvas');
        const ctx = canvas.getContext('2d');
        
        let phase = 'scatter'; 
        let dots = [];
        let lineCount = 120;
        let phaseProgress = 0;
        let extendIndex = 0;
        let offset = 0;
        let retractProgress = 0;

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            initDots();
        }

        function initDots() {
            dots = [];
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const scale = Math.min(canvas.width, canvas.height) / 4;

            for (let i = 0; i < lineCount; i++) {
                const angle = (i / lineCount) * Math.PI * 2;
                const t = angle;
                const x = 16 * Math.pow(Math.sin(t), 3);
                const y = -(13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t));
                
                dots.push({
                    
                    currentX: Math.random() * canvas.width,
                    currentY: Math.random() * canvas.height,
                    
                    targetX: centerX + x * scale / 16,
                    targetY: centerY + y * scale / 16,
                    
                    centerX: centerX,
                    centerY: centerY,
                    angle: angle,
                    lineProgress: 0
                });
            }
        }

        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        function lerp(start, end, t) {
            return start + (end - start) * t;
        }

        function easeInOutCubic(t) {
            return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
        }

        function animate() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (phase === 'scatter') {
                
                dots.forEach(dot => {
                    ctx.fillStyle = 'rgba(255, 20, 147, 1)';
                    ctx.beginPath();
                    ctx.arc(dot.currentX, dot.currentY, 3, 0, Math.PI * 2);
                    ctx.fill();
                });

                phaseProgress += 0.01;
                if (phaseProgress >= 1) {
                    phaseProgress = 0;
                    phase = 'align';
                }
            } 
            else if (phase === 'align') {
                
                const t = easeInOutCubic(phaseProgress);
                
                dots.forEach(dot => {
                    dot.currentX = lerp(dot.currentX, dot.targetX, t);
                    dot.currentY = lerp(dot.currentY, dot.targetY, t);
                    
                    ctx.fillStyle = 'rgba(255, 20, 147, 1)';
                    ctx.beginPath();
                    ctx.arc(dot.currentX, dot.currentY, 3, 0, Math.PI * 2);
                    ctx.fill();
                });

                phaseProgress += 0.015;
                if (phaseProgress >= 1) {
                    phaseProgress = 0;
                    phase = 'extend';
                    extendIndex = 0;
                }
            }
            else if (phase === 'extend') {
                
                dots.forEach((dot, i) => {
                    if (i <= extendIndex) {
                        
                        dot.lineProgress = Math.min(dot.lineProgress + 0.05, 1);
                        
                        const startRatio = 1 - dot.lineProgress;
                        const startX = lerp(dot.centerX, dot.targetX, startRatio);
                        const startY = lerp(dot.centerY, dot.targetY, startRatio);
                        
                        const gradient = ctx.createLinearGradient(startX, startY, dot.targetX, dot.targetY);
                        gradient.addColorStop(0, 'rgba(255, 20, 147, 0.3)');
                        gradient.addColorStop(1, 'rgba(255, 20, 147, 1)');
                        
                        ctx.strokeStyle = gradient;
                        ctx.lineWidth = 2;
                        ctx.lineCap = 'round';
                        
                        ctx.beginPath();
                        ctx.moveTo(startX, startY);
                        ctx.lineTo(dot.targetX, dot.targetY);
                        ctx.stroke();
                    } else {
                        
                        ctx.fillStyle = 'rgba(255, 20, 147, 1)';
                        ctx.beginPath();
                        ctx.arc(dot.targetX, dot.targetY, 3, 0, Math.PI * 2);
                        ctx.fill();
                    }
                });

                if (extendIndex < dots.length - 1 && dots[extendIndex].lineProgress >= 0.8) {
                    extendIndex++;
                }

                if (extendIndex >= dots.length - 1 && dots[dots.length - 1].lineProgress >= 1) {
                    phase = 'retract';
                    retractProgress = 0;
                }
            }
            else if (phase === 'retract') {
                
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                const scale = Math.min(canvas.width, canvas.height) / 4;

                retractProgress += 0.02;
                const retractRatio = Math.min(retractProgress, 1);
                const currentStartRatio = retractRatio * 0.3; 

                dots.forEach((dot) => {
                    const startX = lerp(dot.centerX, dot.targetX, currentStartRatio);
                    const startY = lerp(dot.centerY, dot.targetY, currentStartRatio);
                    
                    const gradient = ctx.createLinearGradient(startX, startY, dot.targetX, dot.targetY);
                    gradient.addColorStop(0, 'rgba(255, 20, 147, 0.3)');
                    gradient.addColorStop(1, 'rgba(255, 20, 147, 1)');
                    
                    ctx.strokeStyle = gradient;
                    ctx.lineWidth = 2;
                    ctx.lineCap = 'round';
                    
                    ctx.beginPath();
                    ctx.moveTo(startX, startY);
                    ctx.lineTo(dot.targetX, dot.targetY);
                    ctx.stroke();
                });

                if (retractProgress >= 1) {
                    phase = 'animate';
                }
            }
            else if (phase === 'animate') {
                
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                const scale = Math.min(canvas.width, canvas.height) / 4;

                for (let i = 0; i < lineCount; i++) {
                    const angle = (i / lineCount) * Math.PI * 2;
                    const t = angle;
                    const x = 16 * Math.pow(Math.sin(t), 3);
                    const y = -(13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t));
                    
                    const endX = centerX + x * scale / 16;
                    const endY = centerY + y * scale / 16;
                    
                    const phaseVal = (i + offset) % lineCount;
                    const lineLength = Math.sin((phaseVal / lineCount) * Math.PI * 2) * 0.5 + 0.5;
                    
                    const startRatio = 0.3 + lineLength * 0.7;
                    const startX = centerX + (endX - centerX) * startRatio;
                    const startY = centerY + (endY - centerY) * startRatio;
                    
                    const gradient = ctx.createLinearGradient(startX, startY, endX, endY);
                    gradient.addColorStop(0, 'rgba(255, 20, 147, 0.3)');
                    gradient.addColorStop(1, 'rgba(255, 20, 147, 1)');
                    
                    ctx.strokeStyle = gradient;
                    ctx.lineWidth = 2;
                    ctx.lineCap = 'round';
                    
                    ctx.beginPath();
                    ctx.moveTo(startX, startY);
                    ctx.lineTo(endX, endY);
                    ctx.stroke();
                }
                
                offset += 0.5;
            }

            requestAnimationFrame(animate);
        }

        animate();
    </script>
</body>
</html>